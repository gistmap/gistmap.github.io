---
title: 记一次有意思的工作任务
date: 2018-03-25 20:42:36
tags: [工作]
categories: 工作
---

### 任务描述
利用注解来完成非默认的权限控制，并把这些需要权限的接口提供出来。

### 完成注解功能
主要提供3个方法分别是：
- 角色集
- 方法的key
- 方法描述

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Access {

    Role[] role() default {};

    String key() default "";

    String desc() default "";
}
```
### 拦截器拦截
主要的思路就是
- 拿到HandlerMethod对象
- 拿到Access注解
- 判断注解，Session是否为空
- Access注解为空直接放行(默认不配置权限)
- Access注解不为空判断身份
- 没找到身份去db里查一遍(2种配置方式)
```java
if (o instanceof HandlerMethod) {
            HandlerMethod hm = (HandlerMethod) o;
            Access access = hm.getMethodAnnotation(Access.class);
            if (access != null) {
                Session session = ServletAttributeCacheUtil.getSession(httpServletRequest, sessionUtil);
                if (session != null) {
                    Role[] roleList = access.role();
                    boolean hasRole = false;
                    for (Role role : roleList) {
                        if (adminService.checkRole(session, role)) {
                            hasRole = true;
                            break;
                        }
                    }
                    if (!hasRole){
                        List<RoleAuthority> result = adminService.getAuthorities(session.roles, access.key());
                        if(!result.isEmpty()) {
                            if (result.get(0).isActive()) {
                                return true;
                            } else {}
                        }else{}
                    } else {
                        return true;
                    }
                    //otu(无权限)
                    return false;
                } else {
                    
                    //out(请登录)
                    return false;
                }
            } else {
                return true;
            }
        }
        return false;
```

### 扫描
找了个ClassTools（这里不附上代码）对指定条件进行扫描，再利用反射拿我们想要的方法属性，组装成对象。这个只附上扫描后的部分。

```java
List<AccessMethod> list = new ArrayList<>();
        for (String clazz : classSet) {
            Class<?> cls = Class.forName(clazz);
            Method[] methods = cls.getDeclaredMethods();
            if (methods != null){
                for (Method method : methods) {
                    AccessMethod accessMethod = new AccessMethod();
                    Annotation annotation = method.getAnnotation(Access.class);
                    if (annotation == null)
                        continue;
                    Method[] ame = annotation.annotationType().getDeclaredMethods();
                    for (Method m : ame) {
                        if (m.getName().equals("key")){
                            String key = m.invoke(annotation,null).toString();
                                accessMethod.accessKey = key;
                                accessMethod.methodName = method.getName();
                                accessMethod.belongCon = cls.getName();
                        }
                        if (m.getName().equals("desc")){
                            String  desc = m.invoke(annotation,null).toString();
                            accessMethod.desc = desc;
                        }
                    }
                    list.add(accessMethod);
                }
            }
        }
```

### 何时扫描
只要加上@PostConstruct注解既可以在启动时运行
### 用Spring自带的类来替代200行的工具类
```java
@PostConstruct
    public void getClassSet() {
        Set<String> classSet = new HashSet<>();
        ClassPathScanningCandidateComponentProvider provider = new ClassPathScanningCandidateComponentProvider(false);
        provider.addIncludeFilter(new AnnotationTypeFilter(RestController.class));
        Set<BeanDefinition> beanDefinitionSet = provider.findCandidateComponents("com.*.web");
        for (BeanDefinition beanDefinition : beanDefinitionSet) {
            classSet.add(beanDefinition.getBeanClassName());
        }
        List<AccessMethod> classes = null;
        try {
            classes = ClassTools.findAccessMethod(classSet);
        } catch (Exception e) {
            throw new BaseException("扫描权限接口错误！");
        }
```

### 放到哪
如果放到redis还需要来会序列化，直接定义一个类标上@Component注解，把@PostConstruct的内容也放进去，因为Spring管理的类是单例的，所以取起来很方便。还可以用java8的lambda分组对Controller进行分组。

```java
@Component
public class AccessCache {

    private Map<String, List<AccessMethod>> cache = null;

    @PostConstruct
    public void getClassSet() {
        Set<String> classSet = new HashSet<>();
        ClassPathScanningCandidateComponentProvider provider = new ClassPathScanningCandidateComponentProvider(false);
        provider.addIncludeFilter(new AnnotationTypeFilter(RestController.class));
        Set<BeanDefinition> beanDefinitionSet = provider.findCandidateComponents("com.fangda.parking.local.web");
        for (BeanDefinition beanDefinition : beanDefinitionSet) {
            classSet.add(beanDefinition.getBeanClassName());
        }
        List<AccessMethod> classes = null;
        try {
            classes = ClassTools.findAccessMethod(classSet);
        } catch (Exception e) {
            throw new BaseException("扫描权限接口错误！");
        }
        Map<String,List<AccessMethod>> groupMap = classes.stream().collect(
                Collectors.groupingBy(AccessMethod::getBelongCon));
        cache = ImmutableMap.copyOf(groupMap);
    }

    public List<AccessMethod> get(String key){
        return cache.get(key);
    }

    public Map<String, List<AccessMethod>> get(){
        return cache;
    }
}
```

### 后记
通过这一次任务，学到了很多，特记于此。如果有疑问，欢迎探讨。