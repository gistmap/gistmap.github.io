---
title: 动态代理那些事
date: 2017-11-9 23:23:34
tags: [java,api]
categories: java
---

## 前言
动态代理是一种精妙的设计模式，他的应用十分广泛，比如AOP，日志系统，RMI等。理解他对后续的学习有很大的帮助。说一个动态代理最通俗的用处，假设现在有几个类同时需要加其某些地方加上一些输出信息，就像Spring AOP的环绕模式，如果我们手动去加，将会十分麻烦且凌乱，动态代理提供一种让别人替我完成这种事情的能力。下面我们从最简单的例子开始做起。

## 最笨的办法

```java
public interface Talking {

	void say(String name);

}
public class TalkingImpl implements Talking {

	@Override
	public void say(String name) {
		before();
		System.out.println(name);
		after();
	}
	private void before() {
		System.out.println("你好");
	}

	private void after() {
		System.out.println("再见");
	}
}
```
如果存在10个需要加上如此功能的类，即使可以将before()，after()抽象出来，但还是需要操作10次，可见过于繁琐。

## 静态代理

```java
public class TalkingProxy implements Talking {
	private TalkingImpl talkingImpl;

	public TalkingProxy(TalkingImpl talkingImpl) {
		this.talkingImpl = talkingImpl;
	}

	@Override
	public void say(String name) {
		talkingImpl.say(name);
	}

	public static void main(String[] args) {
		Talking talking = new TalkingProxy(new TalkingImpl());
		talking.say("二狗子");
	}
}
```
在这次尝试中使用了组合模式将TalkingImpl放在TalkingProxy中，以让程序可以完成TalkingImpl封装好的操作，不过这同时意味着我们需要为多个类创建相应的代理类,诸如XXXProxy...。

## JDK动态代理
```java
public class JDKProxy implements InvocationHandler {

	private Object target;

	public JDKProxy(Object target) {
		this.target = target;
	}

	public <T> T getProxy() {
		return (T) Proxy.newProxyInstance(
				target.getClass().getClassLoader(),
				target.getClass().getInterfaces(),
				this
		);
	}
	@Override
	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
		before();
		Object result = method.invoke(target, args);
		after();
		return result;
	}

	private void after() {
		System.out.println("再见");
	}

	private void before() {
		System.out.println("你好");
	}

	public static void main(String[] args) {
		Talking talking = new JDKProxy(new TalkingImpl()).getProxy();
		talking.say("二狗子");
	}
}
```
使用了JDK的动态代理后，我们只需要一个类即可为不同的类定制相同的行为（这里指before()与after(））。
我们需要了解怎样去使用JDK动态代理：
- 实现InvocationHandler接口并重写invoke方法(定制行为)
- 编写getProxy()方法（获得类的代理）（这部分可以在main里写，为了方便，我把它封装到了代理类内）

值得注意的有Proxy.newProxyInstance()的功能与参数，invoke的参数列表含义。
以下是Proxy.newProxyInstance()源码的部分注释，有兴趣可自行查看。

> Returns an instance of a proxy class for the specified interfaces  that dispatches method invocations to the specified invocation  handler.
> @param   loader the class loader to define the proxy class
> @param   interfaces the list of interfaces for the proxy class to implement
> @param   h the invocation handler to dispatch method invocations to

意思为：返回指定接口的代理类的实例，他将方法指派给调用程序。
第一个参数类型为ClassLoader，需传入所需代理类的ClassLoader。
第二个参数类型为Class<?>[]，需传入所需代理类实现的接口，为Class数组类型，Class<?>为不确定的Java类型。
第三个参数类型为InvocationHandler，可以看到正是我们所实现的接口，他是一个通过代理类实现的调用处理器，传入当前类对象即可。
以下为InvocationHandler.invoke()源码的部分注释。
>  Processes a method invocation on a proxy instance and returns the result.  This method will be invoked on an invocation handler when a method is invoked on a proxy instance that it is associated with.
> @param   proxy the proxy instance that the method was invoked on
> @param   method the {@code Method} instance corresponding to the interface method invoked on the proxy instance.  The declaring class of the {@code Method} object will be the interface that the method was declared in, which may be a superinterface of the proxy interface that the proxy class inherits the method through.
> @param   args an array of objects containing the values of the arguments passed in the method invocation on the proxy instance,or {@code null} if interface method takes no arguments. Arguments of primitive types are wrapped in instances of the appropriate primitive wrapper class, such as {@code java.lang.Integer} or {@code java.lang.Boolean}.

简单的描述为：由代理实例调用方法，返回结果。三个参数分别为：被代理的对象，所要调用的方法及参数，这里注意JDK动态代理是以接口的方式来调用方法，这意味着没有实现接口的类无法使用JDK动态代理来完成代理功能。下面我们来看不需要接口即可实现代理功能的CGLib代理。

## CGLib代理
```java
public class CGLibDynamicProxy implements MethodInterceptor {

	private static CGLibDynamicProxy instance = new CGLibDynamicProxy();

	private CGLibDynamicProxy(){
	}

	public static CGLibDynamicProxy getInstance(){
		return instance;
	}

	public <T> T getProxy(Class<T> cls) {
		return (T) Enhancer.create(cls, this);
	}

	@Override
	public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
		before();
		Object result = methodProxy.invokeSuper(o, objects);
		after();
		return result;
	}

	private void before() {
		System.out.println("你好");
	}

	private void after() {
		System.out.println("再见");
	}

	public static void main(String[] args) {
		Talking talking = CGLibDynamicProxy.getInstance().getProxy(TalkingImpl.class);
		talking.say("李狗蛋");
	}

}
```
至此，我们可以把TalkingImpl中的before()和after()及say中的调用删除，从而在代理类中定制统一的行为。可以看到CGLib代理创建代理类的代码表现形式其实与JDK动态代理很相似，大家可以自己点进源码去观察方法的属性和参数。这里值得一提是在19行，methodProxy调用的并不是invoke()，而是invokeSupe()，这也是为什么CGLib不需要所被代理类的接口作为参数的原因。大家可自己去琢磨。另外以上代码使用了单例模式，那么调用也更加简单了。

由于本人没有研究过两种动态代理的源码，不敢妄自评论。以下是两位朋友对于动态代理讨论的原话：
> 主要是两种代理机制不一样。JDK动态代理本身就是基于接口的，相当于代理了接口中的全部方法，并保证了在新类对象里可以访问原对象。如果没有实现接口，JDK形成的代理类和原类就是兄弟关系，CAST会失败，所以一定要一个接口。CGlib的代理方式，是相当于生成了一个子类，自然可以访问原对象，所以不需要接口。 --Hansen
> 动态代理是利用接口动态生成目标类的代理类，将切面加入到代理类中，所以实现的时候需要有接口，，，CGlib是生成目标类的子类，将切面加入到子类中，所以不需要接口，但是对于final修饰的方法就不行了，，，--e神键之所敲，即吾心之码向

最近在看分布式的书时，尤见动态代理的重要性，特复习加深一遍印象。记于此。
